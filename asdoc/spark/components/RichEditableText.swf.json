{ "type": "class",
  "qname": "spark.components.RichEditableText",
  "baseClassname": "mx.core.UIComponent"
  ,
    "description": "RichEditableText is a low-level UIComponent for displaying, scrolling, selecting, and editing richly-formatted text.  <p>The rich text can contain clickable hyperlinks and inline graphics that are either embedded or loaded from URLs.</p>  <p>RichEditableText does not have scrollbars, but it implements the IViewport interface for programmatic scrolling so that it can be controlled by a Scroller, which does provide scrollbars. It also supports vertical scrolling with the mouse wheel.</p>  <p>It does not include any user interface for changing the formatting of the text. But it offers APIs which can do this programmatically; these make it possible, for example, for you to create a Bold button that makes the selected text bold.</p>  <p>This class is used in the skins of the Spark versions of TextInput and TextArea. (TextInput does not expose its ability to handle rich text, but TextArea does.) By default, RichEditableText has a transparent background, and it does not support drawing a border.</p>  <p>RichEditableText uses the Text Layout Framework (TLF) library, which in turn builds on the Flash Text Engine (FTE) introduced in Flash Player 10. In combination, these layers provide text editing with high-quality international typography and layout.</p>  <p>The Spark architecture provides three text \\&quot;primitives\\&quot; -- Label, RichText, and RichEditableText. Label is the fastest and most lightweight because it uses only FTE, not TLF, but it is limited in its capabilities: no rich text, no scrolling, no selection, and no editing. RichText adds the ability to display rich text with complex layout, but is still completely non-interactive. RichEditableText is the heaviest-weight, but offers most of what TLF can do. In general, use the fastest text primitive that meets your needs.</p>  <p>RichEditableText is similar to the UITextField class used in MX components. This class did not use FTE or TLF but rather extended the older TextField class.</p>  <p>The most important differences between UITextField and RichEditableText are: <ul> <li>RichEditableText offers better typography, better support for international languages, and better text layout.</li> <li>RichEditableText has an object-oriented model of rich text, while UITextField does not.</li> <li>RichEditableText has better support for displaying large amounts of text.</li> <li>RichEditableText requires that fonts be embedded differently than UITextField. Consult the documentation regarding how to use the <code>embedAsCFF</code> attribute when you embed a font.</li> </ul></p>  <p>RichEditableText uses TLF's object-oriented model of rich text, in which text layout elements such as divisions, paragraphs, spans, hyperlinks, and images are represented at runtime by ActionScript objects which can be programmatically accessed and manipulated. The central object in TLF for representing rich text is a TextFlow, so you specify rich text for a RichEditableText control to display by setting its <code>textFlow</code> property to a TextFlow instance. See the description of the <code>textFlow</code> property for information about how to create one, such as by importing TLF markup. If you don't need to display text that has multiple formats, you can use the <code>text</code> property to set a \\&quot;plain text\\&quot; String. See the description of the <code>text</code> and <code>textFlow</code> properties for information about how they interact; for example, you can set one and get the other.</p>  <p>At compile time, you can put TLF markup tags inside the RichEditableText tag, as the following example shows: <pre> &lt;s:RichEditableText&gt;Hello &lt;s:span fontWeight=\\&quot;bold\\&quot;&gt;World!&lt;/s:span&gt;&lt;/s:RichEditableText&gt; </pre> In this case, the MXML compiler sets the <code>content</code> property, causing a TextFlow to be automatically created from the FlowElements that you specify.</p>  <p>The default text formatting is determined by CSS styles such as <code>fontFamily</code>, <code>fontSize</code>. Any formatting information in the TextFlow overrides the default formatting provided by the CSS styles.</p>  <p>You can control the spacing between lines with the <code>lineHeight</code> style and the spacing between paragraphs with the <code>paragraphSpaceBefore</code> and <code>paragraphSpaceAfter</code> styles. You can align or justify the text using the <code>textAlign</code> and <code>textAlignLast</code> styles. You can inset the text from the component's edges using the <code>paddingLeft</code>, <code>paddingTop</code>, <code>paddingRight</code>, and <code>paddingBottom</code> styles.</p>  <p>By default, a RichEditableText \\&quot;autosizes\\&quot;: it starts out very small if it has no text, and grows in width up to <code>maxWidth</code> as you type. It grows in height when you press the Enter key to start a new line.</p>  <p>The <code>widthInChars</code> and <code>heightInLines</code> properties provide a convenient way to specify the width and height in a way that scales with the font size. You can use the <code>typicalText</code> property as well. Note that if you use <code>typicalText</code>, the <code>widthInChars</code> and <code>heightInLines</code> are ignored. You can also specify an explicit width or height in pixels, or use a percent width and height, or use constraints such as <code>left</code> and <code>right</code> or <code>top</code> and <code>bottom</code>.</p>  <p>When you specify some kind of width -- whether an explicit or percent width, a <code>maxWidth</code> or <code>left</code> and <code>right</code> constraints -- the text wraps at the right edge of the component and the text becomes vertically scrollable when there is more text than fits. If you set the <code>lineBreak</code> style to <code>explicit</code>, new lines will start only at explicit lines breaks, such as if you use CR (<code>\\r</code>), LF (<code>\\n</code>), or CR+LF (<code>\\r\\n</code>) in <code>text</code> or if you use <code>&lt;p&gt;</code> and <code>&lt;br/&gt;</code> in TLF markup. In that case, the text becomes horizontally scrollable if any lines are wider than the control.</p>  <p>You can use the <code>maxChars</code> property to limit the number of character that the user can enter, and the <code>restrict</code> to limit which characters the user can enter.</p>  <p>The <code>multiline</code> property determines what happens when you press the Enter key. If it is <code>true</code>, the Enter key starts a new paragraph. If it is <code>false</code>, it causes a <code>FlexEvent.ENTER</code> event to be dispatched.</p>  <p>If you don't want the text to be editable, set the <code>editable</code> property to <code>false</code>. If you don't even want the text to be selectable, set the <code>selectable</code> property to <code>false</code>.</p>  <p>Because RichEditableText uses TLF, it supports displaying left-to-right (LTR) text such as French, right-to-left (RTL) text such as Arabic, and bidirectional text such as a French phrase inside of an Arabic one. If the predominant text direction is right-to-left, set the <code>direction</code> style to <code>rtl</code>. The <code>textAlign</code> style defaults to <code>\\&quot;start\\&quot;</code>, which makes the text left-aligned when <code>direction</code> is <code>ltr</code> and right-aligned when <code>direction</code> is <code>rtl</code>. To get the opposite alignment, set <code>textAlign</code> to <code>end</code>.</p>  <p>As a result of using TLF, the RichEditableText supports unlimited undo/redo within one editing session. An editing session starts when the component gets keyboard focus and ends when it loses focus.</p>  <p>RichEditableText uses TLF's TextContainerManager class to handle its text display, scrolling, selection, editing and context menu.</p>  <p>To use this component in a list-based component, such as a List or DataGrid, create an item renderer. For information about creating an item renderer, see <a href=\\&quot;http://help.adobe.com/en_US/flex/using/WS4bebcd66a74275c3-fc6548e124e49b51c4-8000.html\\&quot;> Custom Spark item renderers</a>. </p>   <p>The <code>&lt;s:RichEditableText&gt;</code> tag inherits all of the tag attributes of its superclass and adds the following tag attributes:</p>  <pre> &lt;s:RichEditableText <strong>Properties</strong> clipAndEnableScrolling=\\&quot;false|true\\&quot; contentHeight=\\&quot;<i>Calculated default</i>\\&quot; contentWidth=\\&quot;<i>Calculated default</i>\\&quot; displayAsPassword=\\&quot;false\\&quot; editable=\\&quot;true\\&quot; heightInLines=\\&quot;NaN\\&quot; horizontalScrollPosition=\\&quot;0\\&quot; imeMode=\\&quot;null\\&quot; maxChars=\\&quot;0\\&quot; multiline=\\&quot;true\\&quot; restrict=\\&quot;null\\&quot; selectable=\\&quot;true\\&quot; selectionActivePosition=\\&quot;-1\\&quot; selectionAnchorPosition=\\&quot;-1\\&quot; selectionHighlighting=\\&quot;TextSelectionHighlighting.WHEN_FOCUSED\\&quot; text=\\&quot;\\&quot; textFlow=\\&quot;<i>TextFlow</i>\\&quot; typicalText=null verticalScrollPosition=\\&quot;0\\&quot; widthInChars=\\&quot;NaN\\&quot;  <strong>Events</strong> change=\\&quot;<i>No default</i>\\&quot; changing=\\&quot;<i>No default</i>\\&quot; enter=\\&quot;<i>No default</i>\\&quot; selectionChange=\\&quot;<i>No default</i>\\&quot; /&gt; </pre>",
  "tags": [
  {  "tagName": "includeExample",
         "values": ["examples/RichEditableTextExample.mxml", "examples/externalTextFlow.xml -noswf"]},
      {  "tagName": "see",
         "values": ["spark.components.Label", "spark.components.RichText", "spark.utils.TextFlowUtil", "flashx.textLayout.container.TextContainerManager"]},
      {  "tagName": "playerversion",
         "values": ["Flash 10", "AIR 1.5"]},
      {  "tagName": "mxml",
         "values": []},
      {  "tagName": "productversion",
         "values": ["Royale 0.9.4"]},
      {  "tagName": "langversion",
         "values": ["3.0"]}  ],
  "members": [
  { "type": "method",
        "qname": "spark.components.RichEditableText",
        "namespace": "",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Constructor.",
        "tags": [
        {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Royale 0.9.4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "",
          "params": []}
      ,
      { "type": "accessor",
        "access": "read-write",
        "return": "Object",
        "qname": "content",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "This property is intended for use in MXML at compile time; to get or set rich text content at runtime, please use the <code>textFlow</code> property instead.  <p>The <code>content</code> property is the default property for RichEditableText, so that you can write MXML such as <pre> &lt;s:RichEditableText&gt;Hello &lt;s:span fontWeight=\\&quot;bold\\&quot;/&gt;World&lt;/s:span&gt;&lt;/s:RichEditableText&gt; </pre> and have the String and SpanElement that you specify as the content be used to create a TextFlow.</p>  <p>This property is typed as Object because you can set it to to a String, a FlowElement, or an Array of Strings and FlowElements. In the example above, you are specifying the content to be a 2-element Array whose first element is the String \\&quot;Hello\\&quot; and whose second element is a SpanElement with the text \\&quot;World\\&quot; in boldface.</p>  <p>No matter how you specify the content, it gets converted into a TextFlow, and when you get this property, you will get the resulting TextFlow.</p>  <p>Adobe recommends using <code>textFlow</code> property to get and set rich text content at runtime, because it is strongly typed as a TextFlow rather than as an Object. A TextFlow is the canonical representation for rich text content in the Text Layout Framework.</p>",
        "tags": [
        {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Royale 0.9.4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]},
      { "type": "accessor",
        "access": "read-write",
        "return": "Boolean",
        "qname": "editable",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "A flag indicating whether the user is allowed to edit the text in this control.  <p>If <code>true</code>, the mouse cursor will change to an i-beam when over the bounds of this control. If <code>false</code>, the mouse cursor will remain an arrow.</p>  <p>If this property is <code>true</code>, the <code>selectable</code> property is ignored.</p>",
        "tags": [
        {  "tagName": "default",
               "values": ["true"]},
            {  "tagName": "see",
               "values": ["spark.components.RichEditableText#selectable"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Royale 0.9.4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]},
      { "type": "accessor",
        "access": "read-write",
        "return": "Number",
        "qname": "heightInLines",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "The default height of the control, measured in lines.  <p>The control's formatting styles, such as <code>fontSize</code> and <code>lineHeight</code>, are used to calculate the line height in pixels.</p>  <p>You would, for example, set this property to 5 if you want the height of the RichEditableText to be sufficient to display five lines of text.</p>  <p>If this property is <code>NaN</code> (the default), then the component's default height will be determined from the text to be displayed.</p>  <p>This property will be ignored if you specify an explicit height, a percent height, or both <code>top</code> and <code>bottom</code> constraints.</p>  <p>This property will also be ignored if the <code>typicalText</code> property is specified.</p>  <p>RichEditableText's <code>measure()</code> method uses <code>widthInChars</code> and <code>heightInLines</code> to determine the <code>measuredWidth</code> and <code>measuredHeight</code>. These are similar to the <code>cols</code> and <code>rows</code> of an HTML TextArea.</p>  <p>Since both <code>widthInChars</code> and <code>heightInLines</code> default to <code>NaN</code>, RichTextEditable \\&quot;autosizes\\&quot; by default: it starts out very small if it has no text, grows in width as you type, and grows in height when you press Enter to start a new line.</p>",
        "tags": [
        {  "tagName": "default",
               "values": ["NaN"]},
            {  "tagName": "see",
               "values": ["spark.components.RichEditableText#widthInChars"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Royale 0.9.4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]},
      { "type": "accessor",
        "access": "read-write",
        "return": "int",
        "qname": "maxChars",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "",
        "tags": [
        {  "tagName": "default",
               "values": ["0"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "copy",
               "values": ["flash.text.TextField#maxChars"]},
            {  "tagName": "productversion",
               "values": ["Royale 0.9.4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]},
      { "type": "accessor",
        "access": "read-write",
        "return": "String",
        "qname": "text",
        "namespace": "public",
        "bindable": ["change"],
        "details": [],
        "deprecated": {},
          "description": "The text String displayed by this component.  <p>Setting this property affects the <code>textFlow</code> property and vice versa.</p>  <p>If you set the <code>text</code> to a String such as <code>\\&quot;Hello World\\&quot;</code> and get the <code>textFlow</code>, it will be a TextFlow containing a single ParagraphElement with a single SpanElement.</p>  <p>If you set the <code>text</code> to null, it will be set to the default value which is an empty string.</p>  <p>If the text contains explicit line breaks -- CR (\\&quot;\\r\\&quot;), LF (\\&quot;\\n\\&quot;), or CR+LF (\\&quot;\\r\\n\\&quot;) -- then the content will be set to a TextFlow which contains multiple paragraphs, each with one span.</p>  <p>If you set the <code>textFlow</code> and get the <code>text</code>, the text in each paragraph will be separated by a single LF (\\&quot;\\n\\&quot;).</p>  <p>Setting this property also affects the properties specifying the control's scroll position and the text selection. It resets the <code>horizontalScrollPosition</code> and <code>verticalScrollPosition</code> to 0. Starting with Royale 0.9.4, the <code>selectionAnchorPosition</code> and <code>selectionActivePosition</code> are preserved. Previously, the <code>selectionAnchorPosition</code> and <code>selectionActivePosition</code> were set to -1 to clear the selection.</p>",
        "tags": [
        {  "tagName": "default",
               "values": ["&quot;&quot;"]},
            {  "tagName": "see",
               "values": ["spark.components.RichEditableText#textFlow", "spark.components.RichEditableText#horizontalScrollPosition", "spark.components.RichEditableText#verticalScrollPosition", "spark.components.RichEditableText#selectionAnchorPosition", "spark.components.RichEditableText#selectionActivePosition"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Royale 0.9.4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]},
      { "type": "accessor",
        "access": "read-write",
        "return": "Number",
        "qname": "widthInChars",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "The default width of the control, measured in em units.  <p>An em is a unit of typographic measurement equal to the point size. It is not necessarily exactly the width of the \\&quot;M\\&quot; character, but in many fonts the \\&quot;M\\&quot; is about one em wide. The control's <code>fontSize</code> style is used, to calculate the em unit in pixels.</p>  <p>You would, for example, set this property to 20 if you want the width of the RichEditableText to be sufficient to display about 20 characters of text.</p>  <p>If this property is <code>NaN</code> (the default), then the component's default width will be determined from the text to be displayed.</p>  <p>This property will be ignored if you specify an explicit width, a percent width, or both <code>left</code> and <code>right</code> constraints.</p>  <p>This property will also be ignored if the <code>typicalText</code> property is specified.</p>  <p>RichEditableText's <code>measure()</code> method uses <code>widthInChars</code> and <code>heightInLines</code> to determine the <code>measuredWidth</code> and <code>measuredHeight</code>. These are similar to the <code>cols</code> and <code>rows</code> of an HTML TextArea.</p>  <p>Since both <code>widthInChars</code> and <code>heightInLines</code> default to <code>NaN</code>, RichTextEditable \\&quot;autosizes\\&quot; by default: it starts out very small if it has no text, grows in width as you type, and grows in height when you press Enter to start a new line.</p>",
        "tags": [
        {  "tagName": "default",
               "values": ["NaN"]},
            {  "tagName": "see",
               "values": ["spark.primitives.heightInLines"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Royale 0.9.4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]}]
  ,
  "events": [
  { "qname": "change",
        "type": "spark.events.TextOperationEvent"
      ,
          "description": "Dispatched after a user editing operation is complete.",
        "tags": [
        {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "eventType",
               "values": ["spark.events.TextOperationEvent.CHANGE"]},
            {  "tagName": "productversion",
               "values": ["Royale 0.9.4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]}]
  }
